---
version: 1.3.1
title: Containers
---

_Tuples_, _Lists_, _Assoc Lists_, _Sets_, _Maps/Hashmaps_, et _Vectors_. (Les termes techniques ne sont volontairement pas traduits et seront affich√©s en _italique_)

{% include toc.html %}

## Quand utiliser tel ou tel _container_ ?

Voici une liste de pense-b√™tes permettant de choisir le bon _container_ en fonction du contexte. 
L'objectif est mn√©motechnique et fera surement plus sens apr√®s avoir lu les chapitres correspondants.

- Besoin d'associer simplement des donn√©es de diff√©rents types ? Utilisons un _[Tuple](#tuples)_
- Besoin d'ajouter des √©l√©ments au d√©but de _container_ (_prepend_) de mani√®re performante ? Utilisons une _[List](#lists)_
- Besoin de garantir l'unicit√© et l'ordre des √©l√©ments ? Utilisons un _[Set](#sets)_
- Besoin de rechercher une valeur √† partir d'une cl√© ? Utilisons une _[Map](#maps)_
- Besoin d'ind√©xer des donn√©es de mani√®re performante ? Utilisons un _[Vector](#vectors)_

## Utiliser les modules (_List_, _Set_, _Map_)

Une fonctionnalit√© appr√©ciable des modules _List_, _Set_ et _Map_ est leur _api_ identique (ou presque). Ainsi, l'utilisation de ces _containers_ est plus intuitive et plus simple √† m√©moriser, permettant un acc√®s rapide √† un large √©ventail d'outils pour un investissement relativement faible.

La contre-partie est l'exposition √† des conflits dans nos imports (_namespace collisions_). C'est une pratique commune et recommand√©e d'utiliser des imports nomm√©s (_qualified imports_). Si vous suivez ce chapitre avec votre interpr√©teur `ghci`, nous vous invitons √† importer les modules comme d√©crit ci-dessous, ainsi tous les modules seront correctement disponibles.

```haskell
ghci> import Data.Set as Set
ghci> import Data.Map as Map
ghci> import Data.List.NonEmpty as NE
ghci> :t Map.empty
Map.empty :: Map k a
ghci> :t Set.empty
Set.empty :: Set.Set a
ghci> :t NE.head
NE.head :: NE.NonEmpty a -> a
```

Afin de se familiariser avec les messages d'erreur, en pr√©vision du jour o√π ils arriveront (et ce jour arrivera :wink:), voici ce qui se produit sans import nomm√© (_unqualified imports_)

```haskell
ghci> import Data.List
ghci> import Data.Set
ghci> import Data.Map
ghci> lookup

<interactive>:4:1: error:
    Ambiguous occurrence ‚Äòlookup‚Äô
    It could refer to
       either ‚ÄòData.Map.lookup‚Äô,
              imported from ‚ÄòData.Map‚Äô
              (and originally defined in ‚ÄòData.Map.Internal‚Äô)
           or ‚ÄòPrelude.lookup‚Äô,
              imported from ‚ÄòPrelude‚Äô (and originally defined in ‚ÄòGHC.List‚Äô)
ghci> empty

<interactive>:5:1: error:
    Ambiguous occurrence ‚Äòempty‚Äô
    It could refer to
       either ‚ÄòData.Map.empty‚Äô,
              imported from ‚ÄòData.Map‚Äô
              (and originally defined in ‚ÄòData.Map.Internal‚Äô)
           or ‚ÄòData.Set.empty‚Äô,
              imported from ‚ÄòData.Set‚Äô
              (and originally defined in ‚ÄòData.Set.Internal‚Äô)
```

## Tuples

Les _Tuples_ sont la premi√®re structure de donn√©e que vous allez d√©couvrir en Haskell. C'est une structure de donn√©e, simple, primitive, avec une syntaxe native et concise. Les champs sont r√©f√©renc√©s selon leurs positions. Th√©oriquement, Les _Tuples_ peuvent contenir un nombre infini de champs, c'est ce qu'on appelle *arit√©* (_arity_). En r√©alit√©, les sp√©cifications _Haskell Report_ n'imposent aux compilateurs (et interpr√©teurs) une taille minimale que de 15 champs (_15-tuple_). `GHC` supporte un nombre de champs allant jusqu'√† 62 (_62-tuple_). Le nombre minimum de champs pour un _tuple_ est de 2 (_2-tuple_). C'est sur ce type que nous nous concentreront √©tant donn√© qu'Haskell fournit de nombreuses fonctionnalit√©s par d√©faut pour celui-ci. A titre d'exemple, voici un _tuple_ avec 8 champs (_8-tuple_).

```haskell
ghci> :t ('0', '1', '2', '3', '4', '5', '6', "8-tuple")
('0', '1', '2', '3', '4', '5', '6', "8-tuple")
  :: (Char, Char, Char, Char, Char, Char, Char, [Char])
```
__Note__: `:t` dans l'interpr√©teur ghci affiche le type de la valeur donn√©e. Il affichera le message sous la forme `valeur :: Type`.

### Quand l'utiliser ?

Un _Tuple_ est utile pour associer des donn√©es, √©ventuellement h√©t√©rog√®nes : "J'ai besoin d'associer ces √©lements". Il n'a pas de valeur *s√©mantique* (sens), mais se concentre sur la *syntaxe* (structure), c'est pourquoi c'est souvent d√©conseill√© d'en abuser. Si la structure de donn√©e √† cr√©er est utilis√©e √† plusieurs endroits de l'application, il est pr√©f√©rable d'utiliser un _Record_. Au contraire, si l'utilisation est isol√©e et locale (interne √† une fonction par exemple) alors un _Tuple_ peut √™tre appropri√©e!

### Comment le cr√©er ?

Un _Tuple_ peut √™tre cr√©√© en utilisant les parenth√®ses avec chaque √©l√©ment s√©par√© par une virgule `(a, b)`.

```haskell
ghci> myTuple = (True, "hello")
ghci> :t myTuple
myTuple :: (Bool, [Char])
```

On peut √©galement laisser un champ vide, il se transforme alors en fonction. Cette technique est appel√© _tuple sectioning_. Elle requiert l'extension `TupleSections`.

```haskell
ghci> :set -XTupleSections
ghci> :t (True,)
(True,) :: t -> (Bool, t)
ghci> :t (,"hello")
(,"hello") :: t -> (t, String)
ghci> :t (,)
(,) :: a -> b -> (a, b)
ghci> (,) True "hello"
(True,"hello")
```
__Note__: Pour activer une extension du langage (_language extension_) depuis l'interpr√©teur ghci on utilise le mot-cl√© `:set` qui permet de d√©finir une option, le prefixe `-X` permet de d√©clarer que c'est une extension du langage qui est directement suivi du nom de l'extension en pascal case.

### Comment le manier ?

La principale mani√®re d'utiliser un _tuple_ est en le d√©composant. L'approche la plus commune est d'utiliser le _pattern matching_ sur la structure du _tuple_ et d'acc√©der √† son contenu. Cette technique est particuli√®rement pratique parce qu'elle fonctionne pour tous types (taille) de tuples.

```haskell
ghci> (\(a, b) -> not a) myTuple
False
ghci> (\(a, b) -> b <> " world") myTuple
"hello world"

ghci> (\(a, b, c) -> a <> " " <> b <> " " <> c) ("my", "name", "is")
"my name is"
```

Avec un _tuple_ d'arit√© de 2 (_2-tuple_), les fonctions `fst` et `snd` sont disponibles dans la biblioth√®que standard. Les _2-tuples_ sont les seuls _tuples_ pour lesquels ces fonctions sont disponibles. Pour les autres _tuples_, il faudra √©crire ses propres fonctions pour acc√©der aux √©lements voulus.

```haskell
ghci> :t fst
fst :: (a, b) -> a
ghci> fst myTuple
True
ghci> :t snd
snd :: (a, b) -> b
ghci> snd myTuple
"hello"
```

### Quelles limitations ?

La principale limitation des _tuples_ en Haskell est que chaque chaque arit√© correspond √† un type disctinct. Il n'y a donc pas de fonction commune pour ajouter un √©l√©ment √† un _tuple_. Ces fonctions doivent donc √™tre √©crites ad hoc (express√©ment pour chaque usage).

Voici un exemple pour augmenter la taille du _tuple_

```haskell
ghci> twoTupleToThreeTuple c (a, b) = (a, b, c)
ghci> twoTupleToThreeTuple () myTuple
(1, "world", ())
```

Tenter d'appeler notre fonction sur un _tuple_ d'arit√© diff√©rente conduira √† une erreur de typage laconique; la fonction attend un _2-tuple_ mais on lui a fournit un _3-tuple_.

```haskell
ghci> twoTupleToThreeTuple True (1, 2, 3)

<interactive>:19:27: error:
    ‚Ä¢ Couldn't match expected type: (a, b)
                  with actual type: (a0, b0, c0)
                  ...
```

## Lists

En terme d'utilisation, les _Lists_ permettent de r√©soudre le probl√®me d'extension qu'on a observer avec les _Tuples_ (capacit√© √† augmenter la taille du _container_ sans cr√©er une nouvelle instance). Par contre, une _List_ ne peut contenir qu'un unique type de donn√©e (elles sont dites homog√®nes). Les _Lists_ sont construites avec une syntaxe sp√©cifique : les crochets avec des virgules s√©parant chaque √©l√©ments.

```haskell
ghci> [1,2,3,4]
[1,2,3,4]
```

### Types inductif/r√©cursif (_Inductive Types_)

Les _Lists_ sont la premi√®re introduction aux types dit "inductif", une sous-cat√©gorie des types "recursifs" (nous y reviendrons dans les concepts avanc√©s). Voici un exemple identique √† l'impl√©mentation en Haskell sans le sucre syntaxique.

```haskell
data List a = Nil | Cons a (List a)
```

On peut voir que ce type est recursif. `Nil` est la valeur de base, le constructeur `Cons` y "adjoint" `a` et appelle r√©cursivement `List a`. On peut √©galement constater pourquoi les _Lists_ ne peuvent contenir qu'un seul type de donn√©es. En effet, la r√©cursion ne porte que sur un type de donn√©es `a`. Dasn notre d√©finition on peut remplacer `Nil` par une _List_ vide `[]` et `Cons` par `:` pour retrouver la syntaxe par d√©faut.

Voici plusieurs exemples √©quivalents pour illustrer cette m√©canique : la cr√©ation par d√©faut d'une _List_, la cr√©ation avec le constructeur `:`, et une cr√©aton manuelle avec le constructeur `Cons`.

```haskell
ghci> [1,2,3,4]
[1,2,3,4]
ghci> 1 : 2 : 3 : 4 : []
[1,2,3,4]
ghci> Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil)))
Cons 1 (Cons 2 (Cons 3 (Cons 4 Nil)))
```

### Quand l'utiliser ?

Les _Linked lists_ sont des structures de donn√©es tr√®s pr√©sentes en programmation fonctionnelle, par cons√©quent vous y serez tr√®s souvent confront√© en Haskell. C'est en g√©n√©ral le premier _container_ auquel on pense. De part, la faible performence de l'ajout d'√©l√©ment en fin de _List_ (_append_) et la relative faible performance d'acc√®s par index (ùõ∞(n) avec n l'index), les _Lists_ sont g√©n√©ralement utilis√©es lorsque l'on sait que l'on va devoir it√©rer sur les √©lements de celles-ci et o√π l'ordre des √©lements est important.

Un bon exemple d'utilisation des _Linked lists_ : impl√©menter une _Stack_ parce que l'ajout et le retrait d'√©l√©ment se font avec une complexit√© ùõ∞(1) (_Last In First Out_).

Un mauvais exemple d'utilisation des _Linked lists_ : impl√©menter une _Queue_ parce que l'ajout ou le retrait d'√©lement se fait avec une complexit√© ùõ∞(n) (_First In First Out_).

Un exemple concret que l'on rencontre souvent dans des applications est la cr√©ationd de requ√™tes en base de donn√©es. Une requ√™te peut retourner soit aucun r√©sultat `[]` soit un certain nombre potentiellement ordonn√©s`[entity..]`. Les biblioth√®ques d'acc√®s aux base de donn√©es ont rarement besoin de garantir un acc√®s par index performant, ainsi elles laissent cette responsabilit√© √† la fonction appelante.

### Concatenation de _Lists_

Pour concater deux listes (ou plus), on utilise l'op√©rateur `++` :

```haskell
ghci> [1, 2] ++ [3, 4, 1]
[1, 2, 3, 4, 1]
```

### Head / Tail

When using lists, it is common to work with a list's head and tail. The head is
the list's first element, while the tail is a list containing the remaining
elements.

Haskell provides two helpful functions, `head` and `tail`, for working with
these parts:

```haskell
ghci> head ["Orange", "Banana", "Apple"]
"Orange"
ghci> tail ["Orange", "Banana", "Apple"]
["Banana","Apple"]
```

Unfortunately these functions reveal an ugly part of the language's base
library; they may raise an exception, even when given an argument with the
appropriate type. The cause of these exceptions is that they do not cover the
full domain of possible inputs.

```haskell
ghci> head []
*** Exception: Prelude.head: empty list
ghci> tail []
*** Exception: Prelude.tail: empty list
```

We can use a common idiom in Haskell for covering partial functions in a safe
way, the `Maybe` type. This allows us to say that unhandled inputs return a
`Nothing`. Now the caller of this maybe-returning-function must handle the
`Nothing` case, but in return they are not faced with a nasty runtime exception.

```haskell
ghci> :i Maybe
data Maybe a = Nothing | Just a 	-- Defined in ‚ÄòGHC.Maybe‚Äô
...
```
__Note__: `:i` in ghci will give you some information about the type, the first
line is the implementation.

Now we can define a total head and tail function using pattern matching!

```haskell
ghci> :{
| safeHead :: [a] -> Maybe a
| safeHead [] = Nothing
| safeHead (x:xs) = Just x
|
| safeTail :: [a] -> Maybe [a]
| safeTail [] = Nothing
| safeTail (x:xs) = Just xs
| :}
ghci> safeHead ["Orange", "Banana", "Apple"]
Just "Orange"
ghci> safeHead []
Nothing
ghci> safeTail ["Orange", "Banana", "Apple"]
Just ["Banana","Apple"]
ghci> safeTail []
Nothing
```
__Note__: `:{` and `:}` allow you to write multiline definitions in ghci.

Hooray! No more exceptions.

Another way to ensures that `head` and `tail` are safe is the non-empty list:

```haskell
ghci> import Data.List.NonEmpty
ghci> :i NonEmpty
data NonEmpty a = a .:| [a]
```

From its definition we can see that `NonEmpty` requires the first element to be
present. This symbol `:|` is a constructor just like `:`, in fact the definition of
`NonEmpty` is identical to that of lists, except it omits the `[]` (Nil) case.

This handles the partiality problem the exact opposite way as the
`Maybe` solution. Instead of forcing the caller of the function to guard against
the ill-defined case when handling the result of the function, it forces them to
construct a valid input up front (when calling the function).

```haskell
ghci> import Data.List.NonEmpty as NE
ghci> :t NE.head
NE.head :: NonEmpty a -> a
ghci> head (1 :| [])
1
ghci> NE.head []
<interactive>:11:9: error:
    ‚Ä¢ Couldn't match expected type: NonEmpty a
                  with actual type: [a]
    ...
```

Notice that this time the error is not a runtime exception but a type error, the
compiler is telling us that we tried to use a (potentially empty) list rather
than the required `NonEmpty` type.

### List Performance

Haskell implements lists as linked lists. The cons cells (the operator `:` is
called cons, short for constructor) act as the links. This dictates which
operations can be done quickly and which can be slow:

Prepending a value to a list is easy and fast - all we have to do is create a
new cons cell with the element we want to prepend and point it to the existing
list.

```haskell
prepend value list = value : list
```

On the other hand, since the list data type (as shown above) can be either
empty (`[]` or `Nil`) or a cons cell that will point to the rest of the list,
it does not contain information about the length of the list, or a reference to
the end of the list.

Because of that, in order to retrieve the length of a list we must walk
each cons cell and count until we reach the end of the list. To find the
value at a specific index we need to traverse the list until we reach it.

Similarly, in order to append a list to an existing list, we need to go to the
end of the existing list, and add a cons cell that points to the new list:

```haskell
append originalList newList =
    case originalList of
        [] -> newList
        x : xs -> x : append xs newList
```

The append function defined here is really the same as the `++` operator, as you
might have deduced we need to be careful when using list append. Particularly
`++` inside of loops has quadratic performance!

By virtue of the linked list data structure, many list operations run in linear
time (`ùõ∞(n)`). In many cases the same operation is significantly slower for
lists than for other containers, this is a great reason to be familiar with each
and their tradeoffs!
